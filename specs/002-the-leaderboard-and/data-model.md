# Data Model: Leaderboard and Feedback System

**Feature**: [spec.md](./spec.md) | **Plan**: [plan.md](./plan.md)
**Created**: 2025-01-13
**Status**: Phase 1 Design

## Purpose

Define all entities, relationships, storage schemas, and data flows for the leaderboard and feedback system.

---

## Entities

### 1. User Identity

**Purpose**: Represents a player with persistent identity across game sessions.

**Storage**: Browser cookie + localStorage (client-side)

**Schema**:
```javascript
{
  uuid: string,        // UUIDv4 generated by crypto.randomUUID()
  initials: string,    // 3-letter initials (uppercase)
  created: number      // Unix timestamp (milliseconds)
}
```

**Lifecycle**:
1. Created when player submits first score with initials
2. Stored in cookie with max expiration (2038-01-19)
3. Backed up in localStorage for redundancy
4. Never expires unless manually deleted by user
5. UUID used as primary key in all submissions

**Constraints**:
- `uuid`: 36 characters, format `xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx`
- `initials`: Exactly 3 uppercase letters A-Z
- `created`: Positive integer, milliseconds since epoch

---

### 2. Game Session

**Purpose**: Complete record of a single gameplay session including all data needed for replay, validation, and scoring.

**Storage**: Included in score submission, stored in replay JSON files

**Schema**:
```javascript
{
  sessionHash: string,           // SHA-256 hash (64 hex chars)
  version: number,               // Schema version (1)
  seed: number,                  // RNG seed for word generation
  stage: number,                 // Stage number reached (1-N)
  duration: number,              // Session duration in milliseconds

  // Words presented during session
  words: [
    {
      text: string,              // Word text (e.g., "hello")
      spawnTime: number,         // When word appeared (ms from start)
      completedTime: number,     // When word was completed (ms)
      x: number,                 // Horizontal spawn position (px)
      y: number                  // Vertical spawn position (px, usually 0)
    }
  ],

  // All keystrokes during session
  keystrokes: [
    {
      key: string,               // Key pressed (single char)
      timestamp: number,         // Time since session start (ms)
      wordIndex: number,         // Which word this targeted
      correct: boolean           // Whether keystroke was correct
    }
  ],

  // Calculated stats
  stats: {
    wpm: number,                 // Words per minute (decimal)
    accuracy: number,            // Percentage (0-100, decimal)
    totalKeystrokes: number,     // Total keys pressed
    correctKeystrokes: number,   // Correct keys pressed
    wordsCompleted: number       // Words successfully typed
  }
}
```

**Hash Calculation**:
```javascript
// Deterministic hash from session data
sessionHash = SHA256({
  seed,
  stage,
  words: words.map(w => w.text).sort(),  // Just text, sorted
  keystrokes: keystrokes.map(k => ({
    key: k.key,
    timestamp: k.timestamp,
    wordIndex: k.wordIndex
  }))
})
```

**Lifecycle**:
1. Client tracks all game events during play
2. On game completion, session data compiled
3. Hash calculated from deterministic subset
4. Submitted to queue with user identity
5. Server validates hash matches data
6. Stored as replay JSON file if legitimate

**Constraints**:
- `sessionHash`: Exactly 64 hexadecimal characters
- `seed`: Positive integer
- `stage`: Positive integer 1-N
- `duration`: Positive integer milliseconds
- `words`: Array length 1-1000
- `keystrokes`: Array length 1-10000
- `wpm`: Non-negative decimal, typically 0-300
- `accuracy`: Decimal 0-100

---

### 3. Game Score (Leaderboard Entry)

**Purpose**: Public leaderboard entry linking user identity to gameplay achievement.

**Storage**: Cloudflare KV (queue), static JSON (leaderboard.json)

**Schema**:
```javascript
{
  // Identity
  sessionHash: string,           // References Game Session (PK)
  userId: string,                // References User Identity UUID
  initials: string,              // User's 3-letter initials

  // Performance
  wpm: number,                   // Words per minute
  accuracy: number,              // Accuracy percentage
  stage: number,                 // Stage reached
  timestamp: number,             // Submission time (Unix ms)

  // Validation
  votes: {
    up: number,                  // Thumbs up count
    flags: number                // Flag count
  },

  // References
  replayUrl: string              // Path to replay JSON file
}
```

**Lifecycle**:
1. Client submits score + session data + hash to Cloudflare Worker
2. Worker validates hash, checks for duplicates, enforces rate limits
3. If valid, queued in Cloudflare KV with key `queue:timestamp:uuid`
4. GitHub Actions periodically processes queue
5. Scores sorted by WPM, top 50 added to leaderboard.json
6. Replay data written to `data/replays/{sessionHash}.json`
7. Static files committed and deployed

**Constraints**:
- `sessionHash`: Must match Game Session hash
- `userId`: Must be valid UUIDv4
- `initials`: Exactly 3 uppercase letters
- `wpm`: 0-300 typical range
- `accuracy`: 0-100
- `stage`: 1-N
- `votes.up`: Non-negative integer
- `votes.flags`: Non-negative integer

**Relationships**:
- Each score has exactly one Game Session (1:1)
- Each score belongs to one User Identity (N:1)
- Each score has many Votes (1:N)

---

### 4. Vote

**Purpose**: Records user validation actions (thumbs up or flag) on scores or replays.

**Storage**: Cloudflare KV (queue), aggregated in leaderboard.json and replay JSON files

**Schema**:
```javascript
{
  voteId: string,                // UUIDv4 of this vote
  userId: string,                // UUID of user who voted
  targetHash: string,            // Session hash being voted on
  targetType: string,            // "score" or "replay"
  voteType: string,              // "up" or "flag"
  timestamp: number              // When vote was cast (Unix ms)
}
```

**Lifecycle**:
1. User with valid UID clicks thumbs up or flag button
2. Client submits vote to Cloudflare Worker
3. Worker checks: user has UID, hasn't voted on this target before, rate limit OK
4. If valid, vote stored in KV with key `vote:targetHash:userId`
5. GitHub Actions aggregates votes during processing
6. Vote counts stored in leaderboard.json and replay JSON files
7. Individual votes not published (only aggregated counts)

**Constraints**:
- `userId`: Must have valid User Identity
- `targetHash`: Must reference existing Game Session
- `targetType`: Either "score" or "replay"
- `voteType`: Either "up" or "flag"
- One vote per user per target (enforced by KV key uniqueness)

**Relationships**:
- Each vote belongs to one User Identity (N:1)
- Each vote targets one Game Score (N:1)
- Vote counts aggregated in Game Score entity

---

### 5. Feedback Item

**Purpose**: Bug report or feature request submitted by a player.

**Storage**: Cloudflare KV (queue), static JSON (feedback.json)

**Schema**:
```javascript
{
  // Identity
  feedbackId: string,            // UUIDv4
  userId: string,                // UUID of submitter
  timestamp: number,             // Submission time (Unix ms)

  // Content
  type: string,                  // "bug" or "feature"
  description: string,           // User's description (max 1000 chars)

  // Context
  gameContext: {
    stage: number,               // Current stage
    wpm: number,                 // Current WPM
    accuracy: number,            // Current accuracy
    sessionHash: string | null   // Session hash if game completed
  },

  // Validation
  votes: number,                 // Upvote count
  status: string                 // "open", "acknowledged", "resolved"
}
```

**Lifecycle**:
1. User with UID (or active player) submits feedback
2. If player has no UID but played 3+ words, creates partial session for UID
3. Client submits feedback + game context to Cloudflare Worker
4. Worker validates UID exists, rate limit OK
5. Feedback queued in KV with key `feedback:timestamp:uuid`
6. GitHub Actions processes queue, generates feedback.json
7. Feedback webpage displays items sorted by votes
8. Users with UID can upvote feedback items

**Constraints**:
- `userId`: Must have valid User Identity
- `type`: Either "bug" or "feature"
- `description`: 1-1000 characters
- `gameContext.stage`: Positive integer or null
- `votes`: Non-negative integer
- `status`: One of "open", "acknowledged", "resolved"

**Relationships**:
- Each feedback belongs to one User Identity (N:1)
- Each feedback may reference one Game Session (N:1, optional)
- Each feedback has many upvotes (1:N)

---

## Storage Locations

### Client-Side (Browser)

**Cookies**:
```
typeattack_uid=<uuid>; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/; SameSite=Lax; Secure
```

**localStorage**:
```javascript
{
  "typeattack_uid": "uuid-here",
  "typeattack_initials": "ABC",
  "typeattack_created": "1705161234567"
}
```

---

### Cloudflare KV (Queue)

**Namespace**: `LEADERBOARD_QUEUE`

**Keys**:
- `queue:{timestamp}:{uuid}` → Score submission JSON
- `feedback:{timestamp}:{uuid}` → Feedback submission JSON
- `vote:{targetHash}:{userId}` → Vote JSON
- `ratelimit:{userId}` → Last submission timestamp

**TTL**:
- Queue items: 7 days (604800 seconds)
- Rate limit: 1 hour (3600 seconds)
- Votes: No expiration (permanent)

**Example Queue Entry**:
```javascript
// Key: queue:1705161234567:abc-123-def
{
  "type": "score",
  "userId": "abc-123-def",
  "initials": "ABC",
  "sessionHash": "abc123def456...",
  "sessionData": { /* full Game Session */ },
  "timestamp": 1705161234567
}
```

---

### GitHub Repository (Static Files)

**data/leaderboard.json**:
```javascript
{
  "generated": 1705161234567,    // Last update timestamp
  "version": 1,                  // Schema version
  "scores": [
    {
      "rank": 1,
      "sessionHash": "abc123...",
      "userId": "uuid-here",
      "initials": "ABC",
      "wpm": 145,
      "accuracy": 98.5,
      "stage": 3,
      "timestamp": 1705161200000,
      "votes": { "up": 42, "flags": 1 },
      "replayUrl": "data/replays/abc123.json"
    }
  ]
}
```

**data/feedback.json**:
```javascript
{
  "generated": 1705161234567,
  "version": 1,
  "items": [
    {
      "id": "feedback-uuid",
      "type": "bug",
      "description": "Words overlapping in stage 5",
      "userId": "uuid-here",
      "context": {
        "stage": 5,
        "wpm": 120,
        "timestamp": 1705161200000
      },
      "votes": 15,
      "status": "open"
    }
  ]
}
```

**data/replays/{sessionHash}.json**:
```javascript
{
  "sessionHash": "abc123def456...",
  "version": 1,
  "metadata": {
    "userId": "uuid-here",
    "initials": "ABC",
    "wpm": 145,
    "accuracy": 98.5,
    "stage": 3,
    "duration": 180000,
    "timestamp": 1705161200000
  },
  "gameState": {
    "seed": 12345,
    "words": [ /* array of word objects */ ],
    "keystrokes": [ /* array of keystroke objects */ ],
    "stats": { /* calculated stats */ }
  },
  "votes": {
    "up": 42,
    "flags": 1
  }
}
```

---

## Data Flows

### Flow 1: First Score Submission (New User)

```
1. User completes game
   └─> Client compiles Game Session data

2. Client detects no User Identity
   └─> Prompts for 3-letter initials

3. User enters "ABC"
   └─> Client calls createUserIdentity("ABC")
   └─> UUID generated, stored in cookie + localStorage

4. Client calculates sessionHash from session data
   └─> SHA-256 of deterministic subset

5. Client POSTs to Cloudflare Worker:
   {
     userId: "uuid",
     initials: "ABC",
     sessionHash: "abc123...",
     sessionData: { /* full session */ }
   }

6. Worker validates:
   ✓ Hash matches session data
   ✓ No duplicate sessionHash exists
   ✓ Rate limit OK for this userId
   └─> Stores in KV: queue:timestamp:uuid

7. Worker returns: { success: true, userId: "uuid" }

8. Client displays: "Score submitted! Your ID: uuid"
```

---

### Flow 2: Subsequent Score Submission (Existing User)

```
1. User completes game
   └─> Client compiles Game Session data

2. Client detects existing User Identity
   └─> Retrieves UUID from cookie/localStorage

3. Client calculates sessionHash

4. Client POSTs to Cloudflare Worker (same structure)

5. Worker validates (same checks)

6. If valid, queued and success returned

7. If rate limited: { error: "Rate limited", retryAfter: 42 }
```

---

### Flow 3: Voting on Score/Replay

```
1. User views leaderboard or replay

2. Client checks for User Identity
   └─> If none: voting buttons hidden
   └─> If exists: voting buttons shown

3. User clicks thumbs up on score

4. Client POSTs to Cloudflare Worker:
   {
     userId: "uuid",
     targetHash: "abc123...",
     targetType: "score",
     voteType: "up"
   }

5. Worker validates:
   ✓ User has valid UID
   ✓ Target exists
   ✓ User hasn't voted on this target (check vote:targetHash:userId)
   ✓ Rate limit OK

6. Worker stores vote in KV: vote:targetHash:userId
   └─> Increments vote count (stored separately)

7. Worker returns: { success: true, newCount: 43 }

8. Client updates UI: "👍 43"
```

---

### Flow 4: Feedback Submission (Active Player)

```
1. User playing game (3+ words completed)

2. User clicks feedback button

3. Client checks User Identity
   └─> If none: creates partial session submission
       ├─> Prompts for initials
       ├─> Creates UID
       └─> Submits partial session for identity

4. Client shows feedback form

5. User enters description: "Words overlapping in stage 5"

6. Client POSTs to Cloudflare Worker:
   {
     userId: "uuid",
     type: "bug",
     description: "Words overlapping in stage 5",
     gameContext: {
       stage: 5,
       wpm: 120,
       accuracy: 97.2,
       sessionHash: null  // Game not completed
     }
   }

7. Worker validates:
   ✓ User has valid UID
   ✓ Description length OK
   ✓ Rate limit OK

8. Worker stores in KV: feedback:timestamp:uuid

9. Worker returns: { success: true, feedbackId: "feedback-uuid" }

10. Client displays: "Feedback submitted! Thanks for helping improve the game."
```

---

### Flow 5: GitHub Actions Processing

```
1. Cron triggers every 15 minutes
   └─> GitHub Actions workflow starts

2. Python script process-queue.py runs:

   a. Fetch all queue items from Cloudflare KV
      └─> GET /keys?prefix=queue:
      └─> GET /values/{key} for each key

   b. Validate each submission
      ├─> Recalculate hash, verify match
      ├─> Check for duplicates in existing data
      └─> If invalid: delete from queue, log

   c. Load existing leaderboard.json (if exists)

   d. Merge new valid scores with existing

   e. Sort by WPM descending

   f. Take top 50 scores

   g. For each score:
      ├─> Write replay JSON: data/replays/{hash}.json
      └─> Delete from queue

   h. Aggregate vote counts from KV
      └─> Query all vote:{hash}:* keys
      └─> Count up vs flag votes

   i. Write leaderboard.json atomically
      ├─> Write to .tmp file
      └─> Rename to leaderboard.json

   j. Process feedback items similarly
      └─> Generate feedback.json

3. Git commit generated files:
   git add data/
   git commit -m "Update leaderboard data"
   git push

4. GitHub Pages deploys updated files
   └─> Available via CDN within ~1 minute
```

---

## Validation Rules

### Session Hash Validation
```javascript
// Must match recalculated hash
calculatedHash === submittedHash

// Hash must be unique (no replays)
!existingHashes.includes(submittedHash)
```

### User Identity Validation
```javascript
// UUID format check
/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid)

// Initials format check
/^[A-Z]{3}$/.test(initials)
```

### Rate Limiting
```javascript
// Score submission: Max 1 per minute per user
timeSinceLastSubmission > 60000

// Voting: Max 10 per hour per user
votesInLastHour < 10

// Feedback: Max 5 per hour per user
feedbackInLastHour < 5
```

### Data Integrity
```javascript
// WPM sanity check (flag for review if over 200)
wpm <= 300

// Accuracy bounds
accuracy >= 0 && accuracy <= 100

// Session duration reasonable
duration >= 10000 && duration <= 3600000  // 10s - 1hr

// Keystroke count matches word count roughly
keystrokes.length >= words.length * 3  // Minimum ~3 chars per word
```

---

## Version Management

All JSON schemas include `version` field for forward compatibility.

**Current Version**: 1

**Migration Strategy**:
- Client checks `version` field when loading data
- If version mismatch, client shows update prompt
- Server processes all versions but outputs current version only
- Breaking changes require version bump and migration script

---

## Performance Considerations

**Client-Side**:
- Lazy load replay files (only when clicked)
- Cache leaderboard.json for 5 minutes
- Use Web Workers for hash calculation (non-blocking)

**Server-Side**:
- Batch process queue items (not one-by-one)
- Use atomic file operations (write .tmp, rename)
- Limit replay file size (max 500KB per replay)

**Storage**:
- Cloudflare KV: 25GB limit (won't hit in practice)
- GitHub repo: Keep only top 50 replays, archive older ones
- Static files: Total <10MB for fast loading

---

## Security Considerations

**Client-Side**:
- Use Secure cookie flag (HTTPS only)
- SameSite=Lax prevents CSRF
- No sensitive data in cookies/localStorage

**Server-Side**:
- Validate all inputs (hash, UID format, rate limits)
- Reject oversized payloads (max 1MB per submission)
- Log suspicious activity (impossible scores, rapid submissions)

**Privacy**:
- No IP addresses stored
- No tracking pixels or analytics
- UUID doesn't reveal personal information
- Users can delete cookies to start fresh

---

## Monitoring and Debugging

**Metrics to Track**:
- Queue size (items pending processing)
- Processing time (how long GitHub Actions takes)
- Validation failures (hash mismatches, duplicates)
- Rate limit hits (potential spam attempts)

**Logging**:
- Worker logs: Cloudflare dashboard
- Actions logs: GitHub Actions tab
- Client errors: Browser console (for debugging)

**Debugging Tools**:
- Manual trigger for GitHub Actions workflow
- Test endpoints in Cloudflare Workers
- Local replay validation script
